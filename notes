// NOTE: dom content loaded is the even the browser sends when dom is loaded first
// it is safer to attach to it and then do the things that i want
// w/o it you could manipulate elements that are not in the page
window.addEventListener("DOMContentLoaded", function (event) { })

// can reuse it
window.addEventListener("DOMContentLoaded", function (event) { })


// has a third argument with options ??
// AddEventListenerOptions
const addEventListenerOptions = {
  capture: boolean,
  once: boolean,
  passive: boolean,
  signal: AbortSignal,
}
window.addEventListener("DOMContentLoaded", function (event) { }, addEventListenerOptions)

// NOTE: can create custom events
const myCustomEvent = new Event("mycustomevent")
let elm = document.querySelector("helllo")
elm.dispatchEvent(myCustomEvent)

// NOTE: Add alias to make it less verbose
const $ = (arguments) => document.querySelector.call(this, arguments)
const $$ = (arguments) => document.querySelectorAll.call(this, arguments)
HTMLElement.prototype.on = (a, b, c) => this.addEventListener(a, b, c)
HTMLElement.prototype.off = (a, b, c) => this.removeEventListener(a, b, c)
HTMLElement.prototype.$ = (s) => this.querySelector(s)
HTMLElement.prototype.$ = (s) => this.querySelectorAll(s)
// then you can use it like
let nav = $("nav")



// NOTE: history API
history.pushState(optional_state, null, "/url")
// event created:
window.addEventListener("popstate",)


// NOTE: WEB COMPONENTS
class MyElement extends HTMLElement {
  constructor() { // Set up initial state, event listeners, etc.
    super()
  }

  // life cycle
  connectedCallback() { } // The element is added to the document
  disconnectedCallback() { } // The element is removed to the document
  adoptedCallback() { } // The element has been moved to a new document, from another ShadowDOM

  attributeChangedCallback(name, oldValue, newValue) { }
}

customElements.define("my-element", MyElement);